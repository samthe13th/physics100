<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="../../stylesheets/css/debugger.css" />
</head>

<body>
    <div id="stage"></div>
</body>

</html>
<script type='text/javascript' src="../../js/jquery.min.js"></script>
<script type='text/javascript' src="../../js/raphael.min.js"></script>
<script type='text/javascript' src="../../js/debugger.js"></script>
<script>
    "use strict"
    var $stage = Raphael("stage", 850, 700);
    var $graph_c = { x: 50, y: 100, width: 550, height: 550 };
    var $LineButton = { x: 100, y: 100 };
    var $graph = $stage.rect($graph_c.x, $graph_c.y, $graph_c.width, $graph_c.height);
    var mousex, mousey, line;
    var lines = {};
    var elements = {};
    $graph.attr({
        "stroke": "none"
    })
    var $axis = $stage.path("M" + $graph_c.x + "," + $graph_c.y + ",l0," + $graph_c.height + ",l" + $graph_c.width + ",0");
    $axis.attr({
        "stroke-width": "5px"
    })
    var $anchor_size = 10;
    var $linePoint_size = 10;
    var $points = { x: 10, y: 10 };
    var $space = { x: ($graph_c.width / $points.x), y: ($graph_c.height / $points.y) };
    var app = {
        over: null,
        dragging: false,
        rbody: { name: "", color: "lightgrey" },
        elements: {}
    };
    var dbg = Debugger();
    // dbg.track("mousex");
    // dbg.track("mousey");
    // dbg.track("elements.runner1");
    // dbg.track("elements.runner2");
    dbg.track("app.rbody");
    dbg.track("app.over");
    dbg.track("app.dragging");
    dbg.track("points.point_1_0.id");
    dbg.track("points.point_1_0.x");
    dbg.track("points.point_1_0.y");
    dbg.track("elements.runner1.a1.id");
    dbg.track("elements.runner1.a1");
    function makeGraphCanvas() {
        for (var edge = 0; edge < 4; edge++) {
            var x, y, dir;
            if (edge === 0) {
                y = $graph_c.y;
                x = $graph_c.x;
                dir = "right";
            } else if (edge === 2) {
                y = $graph_c.y + ($space.y * $points.y);
                x = $graph_c.x + $space.x;
                dir = "right";
            } else if (edge === 1) {
                y = $graph_c.y;
                x = $graph_c.x + ($space.x * $points.x);
                dir = "down";
            } else {
                y = $graph_c.y + $space.y;
                x = $graph_c.x;
                dir = "down";
            }
            makeSelectablePoints(edge, x, y, dir);
        }
    }
    var points = {};
    function makeSelectablePoints(edge, x, y, dir) {
        for (var i = 0; i < $points.x; i++) {
            var id = "point_" + + edge + "_" + i;
            var newpoint = Point(x, y, id);
            if (dir === "right") {
                if (edge === 0) {
                    drawGridLine((x + $space.x), y, (x + $space.x), (y + $graph_c.height));
                }
                x += $space.x;
            } else {
                if (edge === 3) {
                    drawGridLine(x, y, (x + $graph_c.width), y);
                }
                y += $space.y;
            }
            points[newpoint.id] = newpoint;
        }
    }
    function getAnchor(name, id) {
        if (name) {
            if (elements[name].a1.id === id) {
                return "a1";
            }
            return "a2"
        }
        return null;
    }
    function Point(x, y, id) {
        var spoint = $stage.circle(x, y, $anchor_size);
        spoint.attr({ "fill": "lightgrey", "stroke": "none", "opacity": "0" });
        spoint.x = x;
        spoint.y = y;
        spoint.id = id;
        spoint.selected = false;
        spoint.over = false;
        spoint.mouseover(function () {
            console.log("over")
            spoint.attr({ "fill": "fff", "opacity": 1, "stroke-width": "4px", "stroke": app.rbody.color, "r": $linePoint_size });
            app.over = { name: spoint.belongsTo(), anchor: getAnchor(spoint.belongsTo(), id), id: spoint.id, x: (spoint.x), y: spoint.y };
            spoint.over = true;
            if (spoint.belongsTo() !== false) {
                console.log("over line point")
                $("body").css("cursor", "move");
            }
        });
        spoint.belongsTo = function () {
            for (var e in elements) {
                if ((elements[e].a1 !== undefined) && (elements[e].a2 !== undefined)) {
                    //console.log("a1.id: " + elements[line].a1.id);
                    if (elements[e].a1.id === spoint.id) {
                        return e
                    };
                    //console.log("a2.id: " + elements[line].a2.id);
                    if (elements[e].a2.id === spoint.id) {
                        return e;
                    }
                }
            }
            return false;
        }
        spoint.name = spoint.belongsTo();
        spoint.mouseout(function () {
            $("body").css("cursor", "default");
            app.over = null;
            spoint.attr("opacity", 0);
        })
        spoint.mousedown(function () {
            spoint.selected = true;
            spoint.attr({ "fill": app.rbody.color, "opacity": 0 });
            if (!elements[app.rbody.name].a1) {
                //  elements[app.rbody.name].a1 = { id: spoint.id, x: spoint.x, y: spoint.y };
                elements[app.rbody.name].a1 = spoint;
                elements[app.rbody.name][spoint.id] = spoint;
                drawLine(spoint);
            } else if (elements[app.rbody.name].a1 && !elements[app.rbody.name].a2) {
                var tpath = "M" + elements[app.rbody.name].a1.x + "," + elements[app.rbody.name].a1.y + ",L" + spoint.x + "," + spoint.y;
                //  elements[app.rbody.name].a2 = { id: spoint.id, x: spoint.x, y: spoint.y };
                elements[app.rbody.name].a2 = spoint;
                elements[app.rbody.name][spoint.id] = spoint;
            } else if (app.over) {
                app.dragging = app.over;
            }
        })
        return spoint;
    }
    function drawGridLine(x1, y1, x2, y2) {
        var pathtxt = "M" + x1 + "," + y1 + ",L" + x2 + "," + y2;
        var path = $stage.path(pathtxt);
        path.attr({
            "stroke-width": "1px",
            "stroke": "black",
            "opacity": "0.2"
        });
    }
    function drawLine(spoint) {
        var path = "M" + spoint.x + "," + spoint.y + ",l0,0";
        line = $stage.path(path);
        line.belongsTo = app.rbody.name;
        line.attr({
            "stroke-width": "6px",
            "stroke": app.rbody.color
        });
        line.mouseover(function () {
            //console.log('over line')
        });
        lines[app.rbody.name] = line;
        elements[app.rbody.name].line = line;
        //console.log("draw line for " + line.belongsTo);
        //console.log("LINES: " + lines);
    }
    function DecCurve(x1, y1, x2, y2, slope, color) {
        var C, curve, slope;
        slope = 1 - slope;
        C = { x: x1 };
        C.y = y1 - (slope * (x2 - C.x));
        // var control = $stage.circle(C.x, C.y, 10).attr({ fill: "lightblue" });
        curve = $stage.path(['M', x1, y1, 'Q', C.x, C.y, x2, y2]);
        curve.attr({ "stroke": color, "stroke-width": "5px" });
        return curve;
    }
    function CurvedPath(x1, y1, x2, y2, slope, type) {
        var C;
        if (type === "acc") {
            C = { y: y1 };
            C.x = x2 - ((C.y - y2) / slope);
        } else {
            slope = 1 - slope;
            C = { x: x1 };
            C.y = y1 - (slope * (x2 - C.x));
        }
        return (["M", x1, y1, "Q", C.x, C.y, x2, y2]);
    }
    function AccCurve(x1, y1, x2, y2, slope, color) {
        var C, curve, slope;
        C = { y: y1 };
        C.x = x2 - ((C.y - y2) / slope);
        // var control = $stage.circle(C.x, C.y, 10).attr({ fill: "lightblue" });
        curve = $stage.path(CurvedPath(x1, y1, x2, y2, slope, "acc"));
        curve.attr({ "stroke": color, "stroke-width": "5px" });
        return curve;
    }
    function addRidgidBody(x, y, color, name, imgsrc) {
        var image_width = 120;
        var image_offset = 40;
        $("body").append("<img class='rbody' id='name" + "_" + color + "'"
            + "style='top: " + (y - image_width) + "px; "
            + "width: " + image_width + "px; "
            + "height: " + image_width + "px; "
            + "left: " + (x + image_offset) + "px' src='" + imgsrc + "'>"
            + "</img>");
        var oset = ButtonSet(x, y, color, name);
        console.log("add body: " + app.rbody.name)
        elements[name] = {};
        console.log("elements: " + elements);
    }
    function ButtonSet(x, y, color, name) {
        var bset = $stage.set();
        var olinebtn = new LineButton(x, y, color, "line", bset);
        var oaccbtn = new LineButton((x + 60), y, color, "acc", bset);
        var odecbtn = new LineButton((x + 120), y, color, "dec", bset);
        bset.rbody = { "name": name, "color": color };
        bset.push(olinebtn);
        bset.push(oaccbtn);
        bset.push(odecbtn);
        return bset;
    }
    function LineButton(x, y, color, type, group) {
        var btnid = color + "_" + type;
        var offcolor = "lightgrey";
        var newbtn = $stage.set();
        var btn1 = $stage.rect(x, y, 50, 50)
            .attr({ "fill": "white" });
        var btn2;
        newbtn.id = btnid;
        newbtn.type = type;
        newbtn.group = group;
        newbtn.push(btn1);
        switch (type) {
            case "line":
                btn2 = $stage.path(["M", (x + 10), (y + 40), "l", 30, -30]);
                break;
            case "acc":
                btn2 = new AccCurve((x + 10), (y + 40), (x + 40), (y + 10), (5), color);
                break;
            case "dec":
                btn2 = new DecCurve((x + 10), (y + 40), (x + 40), (y + 10), (1 / 5), color);
                break;
        }
        newbtn.push(btn2);
        newbtn.attr({ "stroke": offcolor, "stroke-width": 5 });
        newbtn.state = "default";
        newbtn.select = false;
        newbtn.mouseover(function () {
            $("body").css("cursor", "pointer");
            newbtn.attr("stroke", color);
            newbtn.state = "up";
        });
        newbtn.mouseout(function () {
            $("body").css("cursor", "default");
            if (newbtn.state === "down") {
                newbtn.scale(1.1, 1.1);
            };
            if (newbtn.select === false) {
                newbtn.attr("stroke", offcolor);
            }
            newbtn.state = "default";
        });
        newbtn.click(function () {
            setTimeout(function () {
                newbtn.scale(1.1, 1.1);
            }, 60);
            newbtn.scale((1 / 1.1), (1 / 1.1));
            newbtn.selectLine();
        });
        newbtn.selectLine = function () {
            console.log("selectLine");
            app.rbody = newbtn.group.rbody;
            newbtn.group.forEach(function (e) {
                if (e.id === newbtn.id) {
                    newbtn.attr("stroke", color);
                    newbtn.select = true;
                    app.rbody = newbtn.group.rbody;
                    if (!elements[newbtn.group.rbody.name]) {
                        console.log("NEW LINE");
                        elements[newbtn.group.rbody.name] = { linetype: newbtn.type, a1: undefined, a2: undefined };
                    }
                    console.log("CHANGE LINE TYPE OF EXISTING LINE");
                    elements[newbtn.group.rbody.name].linetype = newbtn.type;
                    elements[newbtn.group.rbody.name].linetype = newbtn.type;
                } else {
                    e.attr("stroke", offcolor);
                    e.select = false;
                }
            });
        }
        return newbtn;
    }
    function getUpdatedLinePath(name, x, y, mx, my) {
        var newpath;
        switch (elements[name].linetype) {
            case "line":
                newpath = ["M", x, y, "L", mx, my];
                break;
            case "acc":
                newpath = CurvedPath(x, y, mx, my, 1, "acc");
                break;
            case "dec":
                newpath = CurvedPath(x, y, mx, my, (3 / 5), "dec");
                break;
        }
        return newpath;
    }
    $($stage.canvas).mouseup(function (e) {
        if (app.over && app.dragging) {
            console.log("drop at " + app.over.x + " " + app.over.y);
            // elements[app.dragging.name][app.dragging.anchor].x = app.over.x;
            //elements[app.dragging.name][app.dragging.anchor].y = app.over.y;
            elements[app.dragging.name][app.dragging.anchor] = points[app.over.id];
            console.log("update line from " + app.dragging.name);
        }
        updateLines();
        app.dragging = false;
    });
    function updateLines(){
        for (var e in elements){
            updateLine(e);
        }
    }
    $($stage.canvas).mousemove(function (e) {
        if (line) {
            mousex = e.pageX;
            mousey = e.pageY;
            if (app.dragging) {
                dragHandler();
            } else if (elements[app.rbody.name].a1) {
                updateLine(app.rbody.name);
            }
          // updateLines();
        }
    });
    function updateLine(name) {
        var _a1 = elements[name].a1;
        var tpath, stopAt;
        if (!elements[name].a2) {
            if (app.over) {
                stopAt = getStopPoint(_a1.x, _a1.y, app.over.x, app.over.y);
            } else {
                stopAt = getStopPoint(_a1.x, _a1.y, (mousex - $stage.canvas.parentNode.offsetLeft), (mousey - $stage.canvas.parentNode.offsetTop));
            }
            tpath = getUpdatedLinePath(name, _a1.x, _a1.y, stopAt.x, stopAt.y);
        } else {
            var _a2 = elements[name].a2;
            tpath = getUpdatedLinePath(name, _a1.x, _a1.y, _a2.x, _a2.y);
        }
        lines[name].attr("path", tpath);
        // console.log("update line for " + line.belongsTo);
        // console.log("LINES: " + lines);
    }
    function dragHandler() {
        var tpath, stopAt;
        $('body').css("cursor", "move");
        var p1x, p1y, p2x, p2y;
        if (app.over) {
            if (app.dragging.anchor === "a1") {
                // console.log("get SP for a1")
                stopAt = getStopPoint(app.over.x, app.over.y, elements[app.dragging.name].a2.x, elements[app.dragging.name].a2.y);
            } else if (app.dragging.anchor === "a2") {
                // console.log("get SP for a2");
                stopAt = getStopPoint(elements[app.dragging.name].a1.x, elements[app.dragging.name].a1.y, app.over.x, app.over.y);
            }
        } else {
            if (app.dragging.anchor === "a1") {
                stopAt = getStopPoint((mousex - $stage.canvas.parentNode.offsetLeft), (mousey - $stage.canvas.parentNode.offsetTop), elements[app.dragging.name].a2.x, elements[app.dragging.name].a2.y);
            } else {
                stopAt = getStopPoint(elements[app.dragging.name].a1.x, elements[app.dragging.name].a1.y, (mousex - $stage.canvas.parentNode.offsetLeft), (mousey - $stage.canvas.parentNode.offsetTop));
            }
        }
        if (app.dragging.anchor === "a1") {
            // console.log("drag point 1");
            tpath = getUpdatedLinePath(app.dragging.name, stopAt.x1, stopAt.y1, elements[app.dragging.name].a2.x, elements[app.dragging.name].a2.y);
        } else {
            // console.log("drag point 2");
            tpath = getUpdatedLinePath(app.dragging.name, elements[app.dragging.name].a1.x, elements[app.dragging.name].a1.y, stopAt.x, stopAt.y);
        }
        elements[app.dragging.name].line.attr("path", tpath);
    }
    function getStopPoint(x1, y1, x2, y2) {
        var xdiff = (x2 - x1);
        var ydiff = (y1 - y2);
        // var hypot = Math.sqrt(Math.pow(xdiff, 2) + Math.pow(ydiff, 2));
        var offset = 10;
        var angle = Math.atan(ydiff / xdiff);
        return {
            x: (x2 - offset * Math.cos(angle)), y: (y2 + offset * Math.sin(angle)),
            x1: (x1 + offset * Math.cos(angle)), y1: (y1 - offset * Math.sin(angle))
        };
    }
    makeGraphCanvas();
    addRidgidBody(650, 300, "#fccb04", "runner1", "../../img/runner2.jpg");
    addRidgidBody(650, 600, "#246b8e", "runner2", "../../img/runner1.jpg");

</script>
<style>
    .linebtn {
        position: absolute;
        border-style: solid;
        border-color: lightgrey;
        width: 50px;
        height: 50px;
    }
    
    .rbody {
        position: absolute;
    }
    
    #stage {
        position: absolute;
        left: 20px;
        top: 30px;
    }
</style>